# アクティブウォレットパターン実装ガイド

## 概要

アクティブウォレットパターンは、URL からID (UUID) を省略し、代わりに「現在選択中の家計簿」という概念を導入する実装アプローチです。ユーザーは一度に1つの家計簿のみを操作するため、複数の家計簿を持っていても、常に「アクティブな」家計簿に対して操作を行います。

### メリット

- シンプルで読みやすいURL（例: `/wallet/expenses`）。
- 家計簿IDがURLに露出しにくいため、セキュリティ向上に寄与。
- 実装がシンプルになる場合がある（状態管理への依存度が増す側面もあるため、トレードオフを考慮）。
- ユーザー体験の一貫性が高まる（常にコンテキストが明確なため）。

### デメリット

- ユーザーが直接URLを操作して特定の家計簿をブックマークしたり、共有したりすることが難しくなる。
- 複数の家計簿を同時に開いて比較・操作するといったユースケースには不向き。

## ホーム画面の実装

家計簿ホーム画面（`S-05_wallet_home.yaml`）は、アクティブウォレットパターンにおいて重要な役割を果たします。
この画面は以下の特徴を持ちます：

- `/wallet` パスで直接アクセス可能（ミドルウェアによる適切なリダイレクト後）。
- 現在選択中の（アクティブな）家計簿の概要情報を表示。
- 月次の収支サマリーや支払期限などの主要情報を集約。
- サイドバーメニュー（またはそれに類するナビゲーション）から、アクティブな家計簿に対する全機能へのアクセスポイントとして機能。

## ディレクトリと URL 構造

具体的なディレクトリ構造については、[ディレクトリ構成.md](./ディレクトリ構成.md) を参照してください。

このアプローチでは、以下のような URL 構造を採用します：

- `/login` - ログイン画面
- `/register` - ユーザー登録画面
- `/wallet/select` - 家計簿選択画面
- `/wallet/create` - 家計簿作成画面
- `/wallet` - 家計簿ホーム画面（アクティブな家計簿）
- `/wallet/expenses` - 収支登録画面（アクティブな家計簿）
- `/wallet/payments` - 支払先登録画面（アクティブな家計簿）
- `/wallet/calculations` - 支払額算出設定画面（アクティブな家計簿）
- `/wallet/settings` - 基本設定編集画面（アクティブな家計簿）
- `/wallet/members` - 参加ユーザー管理画面（アクティブな家計簿）
- `/user/settings` - ユーザー設定画面

## 状態管理の実装

アクティブウォレットパターンを実現するためには、クライアントサイドでの状態管理が不可欠です。本プロジェクトでは Zustand を使用します。

### アクティブウォレットストア (`stores/wallet-store.ts`)

現在選択されている家計簿のID (`activeWalletId`)、名前 (`activeWalletName`)、およびユーザーがアクセス可能な家計簿の一覧 (`wallets`) を保持・管理します。この情報は、Zustand の `persist` ミドルウェアを利用して、ユーザーのブラウザの `localStorage` に保存され、セッションを跨いでも状態が維持されます。

```typescript
// stores/wallet-store.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';

interface Wallet {
  id: string;
  name: string;
  // 必要に応じて他の家計簿情報（例：作成日、最終更新日など）も追加可能
}

interface WalletState {
  activeWalletId: string | null;
  activeWalletName: string | null;
  wallets: Wallet[];
  setActiveWallet: (id: string, name: string) => void;
  loadWallets: (userId: string) => Promise<void>;
  clearActiveWallet: () => void;
  isLoading: boolean;
}

export const useWalletStore = create<WalletState>()(
  persist(
    (set, get) => ({
      activeWalletId: null,
      activeWalletName: null,
      wallets: [],
      isLoading: false,
      
      setActiveWallet: (id, name) => set({ 
        activeWalletId: id, 
        activeWalletName: name 
      }),
      
      loadWallets: async (userId: string) => {
        const supabase = createClientComponentClient();
        set({ isLoading: true });
        
        try {
          const { data, error } = await supabase
            .from('wallet_members')
            .select(`
              wallet_id,
              wallets!inner (
                id,
                name
              )
            `)
            .eq('user_id', userId);
            
          if (error) {
            console.error('Supabase error:', error.message);
            throw error;
          }
          
          const walletList = data?.map(item => ({
            id: item.wallets!.id,
            name: item.wallets!.name
          })) || [];
          
          set({ wallets: walletList, isLoading: false });
          
          const { activeWalletId, wallets: currentWallets } = get();
          if (activeWalletId && !currentWallets.find(w => w.id === activeWalletId)) {
            set({ activeWalletId: null, activeWalletName: null });
          } else if (!activeWalletId && currentWallets.length === 1) {
            set({
              activeWalletId: currentWallets[0].id,
              activeWalletName: currentWallets[0].name
            });
          }
        } catch (error) {
          console.error('家計簿一覧の取得/処理に失敗しました:', error);
          set({ wallets: [], isLoading: false });
        }
      },
      clearActiveWallet: () => set ({ activeWalletId: null, activeWalletName: null })
    }),
    {
      name: 'wallet-storage',
    }
  )
);
```

### ユーザー設定ストア (`stores/user-settings-store.ts`)

```typescript
// stores/user-settings-store.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UserSettingsState {
  isMultiWalletEnabled: boolean;
  setMultiWalletEnabled: (enabled: boolean) => void;
}

export const useUserSettingsStore = create<UserSettingsState>()(
  persist(
    (set) => ({
      isMultiWalletEnabled: true, // デフォルトで複数家計簿参加可能
      setMultiWalletEnabled: (enabled) => set({ isMultiWalletEnabled: enabled })
    }),
    {
      name: 'user-settings'
    }
  )
);
```

## ミドルウェアによる自動遷移ロジック実装

Next.js のミドルウェア (`middleware.ts`) を使用して、認証状態やアクティブウォレットの選択状態に基づき、ユーザーを適切なページへ自動的にリダイレクトします。これにより、ユーザー体験の一貫性を保ちつつ、URL構造をシンプルに保ちます。
ミドルウェアはサーバーサイドで実行されるため、Supabaseクライアントは `@supabase/ssr` (旧 `@supabase/auth-helpers-nextjs`) の `createMiddlewareClient` を使用します。

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import type { CookieOptions } from '@supabase/ssr';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return req.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          req.cookies.set({
            name,
            value,
            ...options,
          });
          NextResponse.next({ request: { headers: req.headers } }).cookies.set(
            name, value, options
          );
        },
        remove(name: string, options: CookieOptions) {
          req.cookies.set({
            name,
            value: '',
            ...options,
          });
          NextResponse.next({ request: { headers: req.headers } }).cookies.set(
            name, '', options
          );
        },
      },
    }
  );

  const { data: { session } } = await supabase.auth.getSession();
  
  const path = req.nextUrl.pathname;
  const homeUrl = new URL('/', req.url);
  const loginUrl = new URL('/login', req.url);
  const walletSelectUrl = new URL('/wallet/select', req.url);
  const walletHomeUrl = new URL('/wallet', req.url);

  if (!session) {
    if (
      !path.startsWith('/login') && 
      !path.startsWith('/register') &&
      !path.startsWith('/_next') &&
      !path.startsWith('/api') &&
      !path.startsWith('/favicon.ico') &&
      !path.startsWith('/manifest.json') &&
      !path.startsWith('/icons/')
    ) {
      return NextResponse.redirect(loginUrl);
    }
    return res;
  }

  if (path === '/login' || path === '/register' || path === '/') {
    const userSettingsCookie = req.cookies.get('user-settings')?.value;
    let isMultiWalletEnabled = true;
    try {
      if (userSettingsCookie) {
        const parsedSettings = JSON.parse(userSettingsCookie);
        isMultiWalletEnabled = parsedSettings.state?.isMultiWalletEnabled ?? true;
      }
    } catch (e) {
      console.warn('ユーザー設定Cookieのパースに失敗:', e);
    }

    const walletStorageCookie = req.cookies.get('wallet-storage')?.value;
    let activeWalletId = null;
    let wallets: { id: string; name: string }[] = [];
    try {
      if (walletStorageCookie) {
        const parsedStorage = JSON.parse(walletStorageCookie);
        activeWalletId = parsedStorage.state?.activeWalletId;
        wallets = parsedStorage.state?.wallets || [];
      }
    } catch (e) {
      console.warn('ウォレットストレージCookieのパースに失敗:', e);
    }

    if (wallets.length === 0) {
      return NextResponse.redirect(walletSelectUrl);
    }
    if (isMultiWalletEnabled) {
      return NextResponse.redirect(walletSelectUrl);
    }
    return NextResponse.redirect(walletHomeUrl);
  }
  
  if (
    path.startsWith('/wallet') && 
    path !== '/wallet/select' && 
    path !== '/wallet/create'
  ) {
    const walletStorageCookie = req.cookies.get('wallet-storage')?.value;
    let activeWalletId = null;
    try {
      if (walletStorageCookie) {
        const parsedStorage = JSON.parse(walletStorageCookie);
        activeWalletId = parsedStorage.state?.activeWalletId;
      }
    } catch (e) {
      console.warn('ウォレットストレージCookieのパースに失敗（内部ページアクセス時）:', e);
    }
    
    if (!activeWalletId) {
      return NextResponse.redirect(walletSelectUrl);
    }
  }
  
  return res;
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|manifest.json|icons/).*)',
  ],
};
```

## 家計簿選択画面の実装

ユーザーが参加している家計簿の一覧を表示し、操作対象の家計簿を選択するか、新しい家計簿を作成する画面です。クライアントコンポーネントとして実装され、`useWalletStore` と `useUserSettingsStore` を利用して状態の読み込みと更新を行います。

```typescript
// app/(wallet)/select/page.tsx
'use client';

import { useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useWalletStore } from '@/stores/wallet-store';
import { useUserSettingsStore } from '@/stores/user-settings-store';

const Button = ({ onClick, children, variant }: any) => <button onClick={onClick} className={`p-2 border ${variant === 'outline' ? 'border-blue-500 text-blue-500' : 'bg-blue-500 text-white'}`}>{children}</button>;
const Card = ({ children, onClick, className }: any) => <div onClick={onClick} className={`p-4 border rounded shadow cursor-pointer ${className}`}>{children}</div>;
const Spinner = () => <div className="text-center p-4">Loading...</div>;

export default function WalletSelectPage() {
  const router = useRouter();
  const { 
    wallets, 
    loadWallets, 
    setActiveWallet, 
    isLoading,
    activeWalletId
  } = useWalletStore();
  
  const { 
    isMultiWalletEnabled 
  } = useUserSettingsStore();

  const userId = 'dummy-user-id';
  
  useEffect(() => {
    if (userId) {
      loadWallets(userId);
    }
  }, [loadWallets, userId]);
  
  const handleSelectWallet = useCallback((id: string, name: string) => {
    setActiveWallet(id, name);
    router.push('/wallet');
  }, [setActiveWallet, router]);
  
  const handleCreateWallet = useCallback(() => {
    router.push('/wallet/create');
  }, [router]);
  
  const handleUserSettings = useCallback(() => {
    router.push('/user/settings');
  }, [router]);
  
  useEffect(() => {
    if (activeWalletId && isMultiWalletEnabled) {
      return;
    }

    if (!isMultiWalletEnabled && wallets.length === 1 && wallets[0].id !== activeWalletId) {
      handleSelectWallet(wallets[0].id, wallets[0].name);
    }
  }, [wallets, isMultiWalletEnabled, activeWalletId, handleSelectWallet]);
  
  if (isLoading) {
    return <Spinner />;
  }
  
  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">家計簿を選択</h1>
      
      {wallets.length === 0 ? (
        <p className="mb-4">参加中の家計簿はありません。新しく作成するか、既存の家計簿に参加してください。</p>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {wallets.map((wallet) => (
            <Card 
              key={wallet.id}
              className="p-4 cursor-pointer hover:shadow-md transition-shadow"
              onClick={() => handleSelectWallet(wallet.id, wallet.name)}
            >
              <h2 className="font-semibold text-lg">{wallet.name}</h2>
            </Card>
          ))}
        </div>
      )}
      
      <div className="mt-6 flex gap-4">
        <Button onClick={handleCreateWallet}>
          新しい家計簿を作成
        </Button>
        
        <Button variant="outline" onClick={handleUserSettings}>
          ユーザー設定
        </Button>
      </div>
    </div>
  );
}
```

## アクティブウォレット情報の利用

ウォレット関連ページ共通のレイアウトコンポーネントです。ここでアクティブなウォレットIDの有無をチェックし、未選択の場合は選択画面へリダイレクトするなどの制御を行います。
また、`Sidebar` や `Header` コンポーネントにアクティブなウォレットの情報を渡します。

```typescript
// app/(wallet)/layout.tsx
'use client';

import { useEffect, ReactNode } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { useWalletStore } from '@/stores/wallet-store';

const Sidebar = ({ activeWalletId }: { activeWalletId: string }) => <aside className="w-64 bg-gray-100 p-4">Sidebar (Wallet: {activeWalletId})</aside>;
const Header = ({ walletName }: { walletName: string }) => <header className="p-4 border-b">Header (Wallet: {walletName})</header>;

interface WalletLayoutProps {
  children: ReactNode;
}

export default function WalletLayout({ children }: WalletLayoutProps) {
  const { 
    activeWalletId, 
    activeWalletName,
    loadWallets
  } = useWalletStore();
  
  const router = useRouter();
  const pathname = usePathname();

  const userId = 'dummy-user-id';
  
  useEffect(() => {
    if (userId) {
        loadWallets(userId);
    }
  }, [loadWallets, userId]);

  useEffect(() => {
    if (
      pathname !== '/wallet/select' && 
      pathname !== '/wallet/create' && 
      !activeWalletId
    ) {
      if (typeof window !== 'undefined') {
        router.push('/wallet/select');
      }
    }
  }, [pathname, activeWalletId, router]);
  
  const isSelectOrCreatePage = 
    pathname === '/wallet/select' || 
    pathname === '/wallet/create';
  
  return (
    <div className="flex min-h-screen">
      {!isSelectOrCreatePage && activeWalletId && (
        <Sidebar activeWalletId={activeWalletId} />
      )}
      
      <div className="flex-1 flex flex-col">
        {!isSelectOrCreatePage && activeWalletId && (
          <Header walletName={activeWalletName || '家計簿'} />
        )}
        
        <main className="flex-1 p-4">
          {children}
        </main>
      </div>
    </div>
  );
}
```

## データ取得時のアクティブウォレットID利用

各機能（収支登録、支払先管理など）でSupabaseからデータを取得・更新する際には、`useWalletStore` から `activeWalletId` を取得し、それをクエリの条件（`eq('wallet_id', activeWalletId)`）として使用します。

```typescript
// hooks/use-income-expenses.ts (カスタムフックの例)
import { useState, useEffect, useCallback } from 'react';
import { useWalletStore } from '@/stores/wallet-store';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';

export function useIncomeExpenses(year: number, month: number) {
  const { activeWalletId } = useWalletStore();
  const [data, setData] = useState<IncomeExpense[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const supabase = createClientComponentClient();
  
  const fetchData = useCallback(async () => {
    if (!activeWalletId) {
      setData([]);
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      const startDate = new Date(year, month - 1, 1).toISOString();
      const endDate = new Date(year, month, 0).toISOString();
      
      const { data: fetchedData, error: fetchError } = await supabase
        .from('income_expenses')
        .select('*')
        .eq('wallet_id', activeWalletId)
        .gte('transaction_date', startDate)
        .lte('transaction_date', endDate)
        .order('transaction_date', { ascending: false });
          
      if (fetchError) throw fetchError;
      
      setData(fetchedData || []);
    } catch (err) {
      console.error('収支データの取得に失敗:', err);
      setError(err instanceof Error ? err : new Error(String(err)));
      setData([]);
    } finally {
      setIsLoading(false);
    }
  }, [activeWalletId, year, month]); 

  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { data, isLoading, error, refetch: fetchData };
}
```

## PWA対応の考慮点

## セキュリティ考慮点

アクティブウォレットパターンを安全に実装するためには、以下のセキュリティ対策が不可欠です。

1.  **Row Level Security (RLS) の徹底**

    SupabaseのRLSポリシーを利用して、ユーザーが自身に関連するデータ（参加している家計簿のデータ、自身のプロフィールなど）にのみアクセスできるように制限します。`activeWalletId` はクライアントサイドで管理されるため、サーバーサイドでは常に認証されたユーザー (`auth.uid()`) と `activeWalletId` (リクエストに含まれる場合) の両方を用いて、データの所有権やアクセス権を検証する必要があります。

    ```sql
    -- wallets テーブルのRLSポリシー (既出)
    -- CREATE POLICY "参加者のみ家計簿にアクセス可能"
    --   ON wallets FOR ALL
    --   USING (
    --     EXISTS (
    --       SELECT 1 FROM wallet_members 
    --       WHERE wallet_members.wallet_id = wallets.id 
    --       AND wallet_members.user_id = auth.uid()
    --     )
    --   );

    -- income_expenses テーブルのRLSポリシー (例)
    -- ユーザーは自身がメンバーであるwalletの収支データのみ閲覧・編集可能
    CREATE POLICY "家計簿メンバーのみ収支データアクセス可能" 
      ON income_expenses FOR ALL
      USING (
        auth.uid() IN (
          SELECT user_id FROM wallet_members WHERE wallet_id = income_expenses.wallet_id
        )
      )
      WITH CHECK (
        auth.uid() IN (
          SELECT user_id FROM wallet_members WHERE wallet_id = income_expenses.wallet_id
        )
      );

    -- 他のテーブル (payment_destinations, calculation_settings など) にも同様に、
    -- wallet_id と auth.uid() を組み合わせたRLSポリシーを設定する。
    ```

2.  **Server Actions / API Route での厳格なバリデーション**

    クライアントから送信されるデータ（特に `activeWalletId` やそれに関連する操作対象のID）は、鵜呑みにせず、必ずサーバーサイドで以下の点を確認します。
    *   **認証**: リクエスト元のユーザーが認証済みであるか (`supabase.auth.getUser()` などで確認)。
    *   **所有権/アクセス権**: 要求された操作（読み取り、書き込み、削除）を行う権限がユーザーにあるか。これは、RLSポリシーと連携して機能しますが、Server Action内でも明示的にチェックすることが推奨されます。例えば、特定の `wallet_id` に対する操作を行う前に、その `wallet_id` に現在の `auth.uid()` が `wallet_members` テーブルを通じて関連付けられているかを確認します。
    *   **入力値の妥当性**: Zodなどを用いて、リクエストボディやパラメータの型、フォーマット、必須項目などを検証します。

    ```typescript
    // app/(wallet)/expenses/actions.ts (Server Action の例)
    'use server';

    import { createServerActionClient } from '@supabase/auth-helpers-nextjs'; // 旧ライブラリ
    // import { createServerActionClient } from '@supabase/ssr'; // 推奨: @supabase/ssr を使用
    import { cookies } from 'next/headers';
    import { z } from 'zod';
    import { revalidatePath } from 'next/cache';

    const expenseSchema = z.object({
      walletId: z.string().uuid('無効な家計簿IDです。'),
      amount: z.number().positive('金額は正の数で入力してください。'),
      description: z.string().min(1, '説明を入力してください。').max(100, '説明は100文字以内です。'),
    });

    export async function addExpense(formData: FormData) {
      const supabase = createServerActionClient({ cookies });
      
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        return { error: '認証されていません。ログインしてください。' };
      }
      
      const rawFormData = {
        walletId: formData.get('walletId'),
        amount: formData.get('amount'),
        description: formData.get('description'),
      };

      const validatedFields = expenseSchema.safeParse({
        walletId: rawFormData.walletId,
        amount: Number(rawFormData.amount),
        description: rawFormData.description,
      });

      if (!validatedFields.success) {
        return {
          error: '入力内容にエラーがあります。',
          fieldErrors: validatedFields.error.flatten().fieldErrors,
        };
      }
      
      const { walletId, amount, description } = validatedFields.data;

      const { data: memberCheck, error: memberCheckError } = await supabase
        .from('wallet_members')
        .select('user_id')
        .eq('wallet_id', walletId)
        .eq('user_id', user.id)
        .maybeSingle();

      if (memberCheckError) {
        console.error('メンバーシップ確認エラー:', memberCheckError);
        return { error: '家計簿へのアクセス権限の確認中にエラーが発生しました。' };
      }
      if (!memberCheck) {
        return { error: 'この家計簿に対する操作権限がありません。' };
      }
      
      try {
        const { error: insertError } = await supabase
          .from('income_expenses')
          .insert([{
            wallet_id: walletId,
            user_id: user.id,
            amount: amount,
            description: description,
          }]);
          
        if (insertError) throw insertError;
        
        revalidatePath('/wallet/expenses');
        
        return { success: true, message: '収支項目を追加しました。' };
      } catch (error) {
        console.error('収支追加エラー:', error);
        return { 
          error: error instanceof Error ? error.message : '収支の追加中に不明なエラーが発生しました。' 
        };
      }
    }
    ```

3.  **適切なエラーハンドリングとユーザーフィードバック**
    サーバーサイドでの検証エラーやデータベースエラーが発生した場合、それをクライアントに適切に伝え、ユーザーに分かりやすいフィードバック（トースト通知、フォームエラーメッセージなど）を表示します。

## まとめ

アクティブウォレットパターンの利点は、URLから複雑なIDを排除しながらも、一貫したユーザー体験を提供できる点です。同時に複数の家計簿を操作することはできませんが、ほとんどのユーザーにとってこれは問題にならないでしょう。

ミドルウェアとフロントエンドの状態管理を組み合わせることで、URLを単純化しながらも、画面一覧.mdで定義された起動時自動遷移ロジックを実現できます。また、Supabaseのセキュリティ機能と組み合わせることで、安全かつ使いやすいアプリケーションを構築できます。

PWAとしてホーム画面に追加した場合も、適切な状態管理と復元ロジックにより、シームレスなユーザー体験を提供できます。 